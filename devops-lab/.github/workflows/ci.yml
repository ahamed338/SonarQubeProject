# GitHub Actions CI/CD Workflow
# This workflow runs automatically when you push code to GitHub
# CI/CD = Continuous Integration / Continuous Deployment
#
# CI: Automatically test and validate code changes
# CD: Automatically deploy when tests pass (we're simulating this)

name: DevOps Lab CI/CD Pipeline

# When to trigger this workflow
on:
  push:
    branches: [ main, master ]  # Runs on push to main/master branch
  pull_request:
    branches: [ main, master ]   # Runs on pull requests
  workflow_dispatch:  # Allows manual triggering from GitHub UI

jobs:
  # Job 1: Lint and Validate YAML Files
  # Ensures all YAML files are properly formatted and valid
  lint:
    name: Validate YAML Files
    runs-on: ubuntu-latest  # Free GitHub-hosted runner
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      # Downloads your repository code to the runner
      
    - name: Validate Docker Compose
      run: |
        echo "üîç Validating docker-compose.yml..."
        docker compose -f sonar-docker/docker-compose.yml config || docker-compose -f sonar-docker/docker-compose.yml config
        # This checks if docker-compose.yml syntax is correct
        # If there's an error, the workflow fails (CI catch errors early!)
      
    - name: Validate Helm Chart
      run: |
        echo "üì¶ Validating Helm chart..."
        # In real scenarios, you'd install helm: brew install helm
        # For now, we'll check YAML syntax manually
        if command -v helm &> /dev/null; then
          helm lint helm-learn/ || echo "‚ö†Ô∏è  Helm not installed - skipping"
        else
          echo "‚ÑπÔ∏è  Helm CLI not available (expected in GitHub Codespaces)"
          echo "‚úÖ YAML syntax would be validated in production pipeline"
        fi
    
    - name: YAML Lint Check
      run: |
        echo "üîç Running YAML linting..."
        if command -v yamllint &> /dev/null; then
          yamllint -c .yamllint.yml . || echo "‚ö†Ô∏è  yamllint issues found (non-blocking)"
        else
          echo "‚ÑπÔ∏è  yamllint not installed - skipping"
          echo "üí° Install with: pip install yamllint"
          echo "‚úÖ YAML syntax would be validated in production pipeline"
        fi
      continue-on-error: true  # Don't fail workflow on lint warnings

  # Job 2: Terraform Validation
  # Ensures Terraform code is properly formatted and valid
  terraform:
    name: Validate Terraform Code
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.0  # Install specific Terraform version
    
    - name: Terraform Format Check
      run: |
        echo "üîß Checking Terraform formatting..."
        cd terraform-local
        terraform fmt -check
        # Ensures all .tf files follow consistent formatting
        # In real CI/CD, you'd fail if format check fails
    
    - name: Terraform Init
      run: |
        cd terraform-local
        terraform init
        # Downloads required providers (local, docker)
        # This validates that terraform code is syntactically correct
    
    - name: Terraform Validate
      run: |
        cd terraform-local
        terraform validate
        # Validates Terraform configuration files
        # Catches errors without creating actual resources
    
    - name: Terraform Plan (Dry Run)
      run: |
        cd terraform-local
        terraform plan -out=tfplan
        # Shows what Terraform would create/change
        # In real scenarios, you'd save this plan and apply it in a deployment job
      continue-on-error: true  # Don't fail workflow if Docker isn't available

  # Job 3: Security Scanning with Checkov
  # Checkov scans Infrastructure as Code (Terraform, Docker, Kubernetes) for security issues
  # It checks for common misconfigurations, vulnerabilities, and compliance violations
  security-scan:
    name: Security Scanning (Checkov)
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Run Checkov Security Scan
      uses: bridgecrewio/checkov-action@master
      with:
        directory: .
        framework: terraform,dockerfile,docker_compose,kubernetes,helm
        output_format: cli
        soft_fail: true  # Don't fail workflow, just report issues
        download_external_modules: true
      env:
        CHECKOV_CONFIG_FILE: .checkov.yml
    
    - name: Checkov Results Summary
      run: |
        echo "üîí Security Scanning Complete"
        echo ""
        echo "Checkov scans for:"
        echo "- Security misconfigurations"
        echo "- Compliance violations"
        echo "- Vulnerabilities in IaC"
        echo "- Best practice violations"
        echo ""
        echo "üí° Review the output above for security findings"
        echo "üìö Learn more: https://www.checkov.io/"

  # Job 4: Simulated SonarQube Scan
  # In real scenarios, this would:
  # - Start SonarQube server (or connect to existing)
  # - Run code quality analysis
  # - Report code smells, bugs, security vulnerabilities
  # - Fail pipeline if quality gates aren't met
  sonarqube-scan:
    name: Code Quality Analysis
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Simulate SonarQube Analysis
      run: |
        echo "üîç Running SonarQube code analysis..."
        echo ""
        echo "=== Simulated SonarQube Scan Results ==="
        echo "‚úÖ No critical issues found"
        echo "‚úÖ Code coverage: 85%"
        echo "‚úÖ Technical debt: Low"
        echo "‚úÖ Security vulnerabilities: 0"
        echo ""
        echo "In a real pipeline, this would:"
        echo "1. Start SonarQube container or connect to SonarQube server"
        echo "2. Run: sonar-scanner -Dsonar.projectKey=my-project"
        echo "3. Analyze code quality, security, and maintainability"
        echo "4. Upload results to SonarQube dashboard"
        echo "5. Check quality gates (pass/fail criteria)"
        echo "6. Block deployment if quality gates fail"
        echo ""
        echo "üìä View results at: http://localhost:9000 (when SonarQube is running)"
        
    # Real SonarQube step (commented out - needs SonarQube server):
    # - name: Run SonarQube Scanner
    #   uses: sonarsource/sonarqube-scan-action@master
    #   env:
    #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
    #     SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

  # Job 5: Summary
  # Provides a summary of all checks
  summary:
    name: CI/CD Pipeline Summary
    runs-on: ubuntu-latest
    needs: [lint, terraform, security-scan, sonarqube-scan]
    if: always()  # Run even if previous jobs fail
    
    steps:
    - name: Pipeline Summary
      run: |
        echo "üìã DevOps Lab CI/CD Pipeline Summary"
        echo "===================================="
        echo ""
        echo "‚úÖ YAML files validated"
        echo "‚úÖ Terraform code formatted and validated"
        echo "‚úÖ Security scanning completed (Checkov)"
        echo "‚úÖ Code quality analysis completed"
        echo ""
        echo "üéì Learning Points:"
        echo "- CI/CD automates testing and validation"
        echo "- Pipelines catch errors before deployment"
        echo "- Multiple jobs run in parallel for speed"
        echo "- Real pipelines would deploy to staging/production"
        echo ""
        echo "üöÄ Next Steps:"
        echo "1. Review any failed checks above"
        echo "2. Fix issues and push again"
        echo "3. In production, add deployment jobs after all tests pass"

